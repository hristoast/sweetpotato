#!/usr/bin/env python3
"""A tool for managing Minecraft servers on GNU/Linux."""
import argparse
try:
    import bottle
except ImportError:
    bottle = None
import configparser
import json
import logging
import os
import pty
import shlex
import subprocess
import sys
import time
import tarfile
import urllib.request

from datetime import datetime
try:
    from markdown import markdown
except ImportError:
    markdown = None


__author__ = 'Hristos N. Triantafillou <me@hristos.triantafillou.us>'
__forgeversion__ = '1.7.10-10.13.2.1230'
__license__ = 'GPLv3'
__mcversion__ = '1.8'
__progname__ = 'sweetpotato'
__version__ = '0.3 BETA'


BASE_DIR = os.path.dirname(__file__)
DESCRIPTION = "Manage your Minecraft server on a GNU/Linux system."
HOME_DIR = os.getenv('HOME')
CONFIG_DIR = '{0}/.config/{1}'.format(HOME_DIR, __progname__)
LOCK_FILE_NAME = '{0}/sweetpot.lock'.format(CONFIG_DIR)
DEFAULT_CONF_FILE = '{0}/{1}.conf'.format(CONFIG_DIR, __progname__)
DEFAULT_SCREEN_NAME = 'sweetpotato_mc'
REQUIRED = 'backup_dir mem_format mem_max mem_min port server_dir world_name'
RESTART_WAIT = 2
VANILLA_DL_URL = 'https://s3.amazonaws.com/Minecraft.Download/versions/{0}/{1}'
VANILLA_JAR_NAME = 'minecraft_server.{0}.jar'


class Colors:
    blue = '\033[34m'
    light_blue = '\033[94m'
    yellow_green = '\033[92m'
    green = '\033[32m'
    light_red = '\033[91m'
    red = '\033[31m'
    yellow = '\033[33m'
    end = '\033[0m'


class SweetpotatoIOErrorBase(IOError):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return repr(self.msg)


class BackupFileAlreadyExistsError(SweetpotatoIOErrorBase):
    """Raised when the target backup file already exists."""
    pass


class ConfFileError(SweetpotatoIOErrorBase):
    """Raised when a given conf file doesn't exist or have the right section."""
    pass


class EmptySettingError(SweetpotatoIOErrorBase):
    """Raised when a required setting value is None."""
    pass


class MissingExeError(SweetpotatoIOErrorBase):
    """Raised when a required executable is missing."""
    pass


class ServerAlreadyRunningError(SweetpotatoIOErrorBase):
    """Raised when the configured server is already running."""
    pass


class ServerNotRunningError(SweetpotatoIOErrorBase):
    """Raised when the server is not running but was expected to be."""
    pass


class SweetpotatoConfig:
    header = "# Generated by {0} at {1}\n[Settings]".format(__progname__, datetime.now().strftime('%c'))

    def __init__(self):
        self.backup_dir = None
        self.conf_file = None
        self.force = False
        self.forge = None
        self.level_seed = None
        self.mem_format = None
        self.mem_max = None
        self.mem_min = None
        self.mc_version = __mcversion__
        self.port = str(25565)
        self.screen_name = DEFAULT_SCREEN_NAME
        self.server_dir = None
        self.world_name = None
        self.z = 'gzip'

    def as_conf_file(self):
        print(self.header)
        return [
            print('{0}: {1}'.format(line, value))
            for line, value in self.__dict__.items()
            if value is not None and line is not 'conf_file' and line is not 'force'
        ]

    def as_json(self):
        return json.dumps(self.__dict__, sort_keys=True, indent=4)

    def as_serverproperties(self):
        vanilla_server_properties_18 = """## Minecraft server properties
#{0}
generator-settings=
op-permission-level=4
allow-nether=true
resource-pack-hash=
level-name={1}
enable-query=false
allow-flight=false
announce-player-achievements=true
server-port={2}
max-world-size=29999984
level-type=DEFAULT
enable-rcon=false
level-seed={3}
force-gamemode=false
server-ip=
network-compression-threshold=256
max-build-height=256
spawn-npcs=true
white-list=false
spawn-animals=true
hardcore=false
snooper-enabled=true
online-mode=true
resource-pack=
pvp=true
difficulty=1
enable-command-block=false
gamemode=0
player-idle-timeout=0
max-players=20
max-tick-time=60000
spawn-monsters=true
generate-structures=true
view-distance=10
motd=Welcome to {1}!
        """.format(self.header, self.world_name, self.port, self.level_seed or '')
        return vanilla_server_properties_18


def agree_to_eula(eula_txt, force, print_pre):
    """
    Checks for a eula.txt file in server, and verifies it contains 'eula=true'.

    @param eula_txt:
    @param force:
    @param print_pre:
    @return:
    """
    # TODO: not do this if the MC version is low enough
    if os.path.isfile(eula_txt) and not force:
        f = open(eula_txt, 'r')
        if 'eula=true' in f.read():
            f.close()
            print(print_pre + Colors.light_blue + 'Eula agreed to!' + Colors.end)
            return True
        else:
            f.close()
    print(print_pre + Colors.light_blue + 'Agreeing to the eula ...', end=' ')
    f = open(eula_txt, 'w')
    f.write('eula=true\n')
    f.close()
    print('Done!' + Colors.end)
    return True


def create_server(settings):
    """
    Check for or create the configured server dir, check for or download the
    server jar for the configured mc_version, then ensure that server.properties
    matches what our desired configurations are.

    @param settings:
    @return:
    """
    print_pre = '[' + Colors.yellow_green + 'create' + Colors.end + '] '
    force = settings.force
    mc_version = settings.mc_version
    server_dir = settings.server_dir
    world_name = settings.world_name

    print(print_pre + Colors.blue + 'Creating "{}" ...'.format(world_name) + Colors.end)
    if not os.path.isdir(server_dir):
        print(print_pre + Colors.light_blue + 'Creating {} ...'.format(server_dir), end=' ')
        sys.stdout.flush()
        list_or_create_dir(server_dir)
        print('Done!' + Colors.end)
    else:
        print(print_pre + Colors.light_blue + 'Found {}!'.format(server_dir) + Colors.end)

    if not settings.forge:
        jar_name = VANILLA_JAR_NAME.format(mc_version)
        full_jar_path = os.path.join(server_dir, jar_name)
        if not os.path.isfile(full_jar_path) or force:
            print(print_pre + Colors.light_blue + 'Downloading {} ...'.format(jar_name), end=' ')
            sys.stdout.flush()
            dl_url = VANILLA_DL_URL.format(mc_version, jar_name)
            local_jar = urllib.request.urlretrieve(dl_url, full_jar_path)[0]
            jar = open(local_jar)
            jar.close()
            print('Done!' + Colors.end)
        else:
            print(print_pre + Colors.light_blue + 'Found {}!'.format(jar_name) + Colors.end)
    else:
        print('DO FORGE THINGS!')

    eula_txt = os.path.join(server_dir, 'eula.txt')
    agree_to_eula(eula_txt, force, print_pre)

    server_properties = os.path.join(server_dir, 'server.properties')
    write_server_properties(print_pre, server_properties, settings)

    print(print_pre + Colors.blue + 'World "{}" has been created!'.format(world_name) + Colors.end)


def dependency_check(*deps):
    if None in deps:
        raise MissingExeError("Unable to find all dependencies. Please ensure that screen and java are installed.")


def error_and_die(msg):
    """
    For those times when you just want to quit and say why.

    @param msg:
    @return:
    """
    sys.stderr.write(
        Colors.light_red + 'FATAL: ' + Colors.red + msg.__str__().strip("'") + Colors.end + '\n'
    )
    sys.exit(1)


def get_exe_path(exe):
    """
    Checks for exe in $PATH.

    @param exe:
    @return:
    """
    p = subprocess.Popen(['which', exe], stdout=subprocess.PIPE)
    byte_output = p.communicate()[0]
    return byte_output.decode().strip() or None


def get_java_procs():
    """Checks for running Java processes and return the cwd, exe, and pid of any we find."""
    cwd, exe, pid = None, None, None
    p = subprocess.Popen(['pgrep', 'java'], stdout=subprocess.PIPE)
    output = p.communicate()[0]

    if output and len(output.split()) is 1:
        # One Java process
        pid = output.decode().strip()
        c = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/cwd'.format(pid)], stdout=subprocess.PIPE)
        c_out = c.communicate()[0]
        cwd = c_out.decode().split()[-1]
        e = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/exe'.format(pid)], stdout=subprocess.PIPE)
        e_out = e.communicate()[0]
        exe = e_out.decode().split()[-1]
    elif output and len(output.split()) > 1:
        # More than one Java process
        proc_list = []
        for P in output.decode().split():
            pid = P
            c = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/cwd'.format(pid)], stdout=subprocess.PIPE)
            c_out = c.communicate()[0]
            cwd = c_out.decode().split()[-1]
            e = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/exe'.format(pid)], stdout=subprocess.PIPE)
            e_out = e.communicate()[0]
            exe = e_out.decode().split()[-1]
            proc_list.append((cwd, exe, pid))
        return proc_list

    if cwd and exe and pid:
        return cwd, exe, pid
    else:
        return None


def is_screen_started(screen_name):
    l = []

    proc = subprocess.Popen(['screen', '-ls', '{0}'.format(screen_name)], stdout=subprocess.PIPE)
    output = proc.communicate()[0]
    new_output = output.decode().split('\n')
    split_output = output.split()

    for split_o in split_output:
        l.append(split_o.decode())

    if 'No Sockets found' in ' '.join(l[:3]):
        return False
    elif 'There is a screen' in ' '.join(l[:4]):
        for new_o in new_output:
            if screen_name in new_o:
                return new_o.split()[0]
    elif 'There are screens' in ' '.join(l[:3]):
        screen_list = []
        for out in new_output:
            if screen_name in out:
                for part in out.split():
                    if screen_name in part:
                        screen_list.append(part)
        return screen_list


def is_server_running(server_dir_name):
    java_procs = get_java_procs()
    server_dir = server_dir_name.rstrip('/')
    if isinstance(java_procs, tuple):
        # just one java proc
        if server_dir in java_procs:
            return java_procs
        else:
            return False
    elif isinstance(java_procs, list):
        # multiple java procs
        for proc in java_procs:
            if server_dir in proc[0]:
                return proc
    return False


def list_or_create_dir(d):
    """
    Returns a list of config files in the config directory, creating the folder if it does not exist.

    :param d:
    """
    # TODO: test this with a directory that we don't have permission to write
    if not os.path.isdir(d):
        os.makedirs(d)
    return os.listdir(d)


def read_conf_file(file, settings):
    """
    The arg 'file' is a conf file path, and 'settings' is a dict containing your settings.

    Checks if 'file' is actually a file, if not checks for 'DEFAULT_FILE'. If that doesn't exist, we return 'settings'
    as it was passed in, the value for 'settings["CONFIG"]' remaining 'None'.

    :param file:
    :param settings:
    """
    # TODO: handle multiple servers by using their world name as a section header name
    # TODO: come up with a system for this
    if not os.path.isfile(file):
        raise ConfFileError('The specified conf file does not exist: {}'.format(file))

    section = 'Settings'
    c = configparser.ConfigParser()
    c.read(file)

    try:
        options = c.options(section)
    except configparser.NoSectionError:
        raise ConfFileError("The specified conf file does not have a valid 'Settings' section")

    options_dict = {}
    for o in options:
        options_dict[o] = c.get(section, o)
    return settings.__dict__.update(**options_dict)


def send_command(command, screen_name):
    """
    Send a command to the server.

    @param command:
    @param screen_name:
    @return:
    """
    cmd_line = 'screen -S {0} -X eval \'stuff "{1}"\015\''.format(screen_name, command)
    cmd_list = shlex.split(cmd_line)
    subprocess.call(cmd_list)


def start_screen(screen_name, server_dir):
    command = 'screen -dmS {0}'.format(screen_name)
    os.chdir(server_dir)
    master, slave = pty.openpty()
    cmd_args = shlex.split(command)
    subprocess.Popen(cmd_args, close_fds=True, shell=False, stdin=slave, stdout=slave, stderr=slave)


def start_server(print_pre, settings):
    jar_name = VANILLA_JAR_NAME.format(settings.mc_version)
    mem_format = settings.mem_format
    mem_max = settings.mem_max
    mem_min = settings.mem_min
    screen_name = settings.screen_name
    server_dir = settings.server_dir
    world_name = settings.world_name

    screen_started = is_screen_started(screen_name)
    server_running = is_server_running(server_dir)

    if not screen_started:
        start_screen(screen_name, server_dir)

    if not server_running:
        if print_pre:
            print(print_pre + Colors.light_blue + 'Starting "{}" ...'.format(world_name), end=' ')
        else:
            print('starting "{}" ...'.format(world_name), end=' ')
        sys.stdout.flush()
        launch_server = 'java -Xms{0}{2} -Xmx{1}{2} -jar {3} nogui'.format(mem_min, mem_max, mem_format[0], jar_name)
        send_command(launch_server, screen_name)
        print('Done!' + Colors.end)
    else:
        raise ServerAlreadyRunningError('World "{0}" already running with PID {1}'.format(
            settings.world_name,
            server_running[-1]
        ))


def stop_server(print_pre, screen_name, server_dir, world_name):
    server_running = is_server_running(server_dir)

    if server_running:
        print(print_pre + Colors.light_blue + 'Stopping "{}" ...'.format(world_name), end=' ')
        sys.stdout.flush()
        send_command('stop', screen_name)
        print('Done!' + Colors.end)
    else:
        raise ServerNotRunningError('Cannot stop "{}" - it is not running!'.format(world_name))


def restart_server(print_pre, settings):
    jar_name = VANILLA_JAR_NAME.format(settings.mc_version)
    mem_format = settings.mem_format
    mem_max = settings.mem_max
    mem_min = settings.mem_min
    launch_server = 'java -Xms{0}{2} -Xmx{1}{2} -jar {3} nogui'.format(mem_min, mem_max, mem_format[0], jar_name)
    screen_name = settings.screen_name
    server_dir = settings.server_dir
    world_name = settings.world_name

    screen_started = is_screen_started(screen_name)
    server_running = is_server_running(server_dir)

    if not screen_started:
        start_screen(screen_name, server_dir)

    if server_running:
        server_pid = server_running[-1]
        print(print_pre + Colors.light_blue + 'Restarting {} ...'.format(world_name), end=' ')
        sys.stdout.flush()
        send_command('stop', screen_name)
        while os.path.exists("/proc/{0}".format(server_pid)):
            # in case we've tried to stop before the server has fully started
            time.sleep(0.5)
            send_command('stop', screen_name)
    else:
        print(print_pre + Colors.light_blue + 'Starting {} ...'.format(world_name), end=' ')
        sys.stdout.flush()
    send_command(launch_server, screen_name)
    print('Done!' + Colors.end)


def run_server_backup(print_pre, settings, offline=False):
    backup_dir = settings.backup_dir
    date_stamp = datetime.now().strftime('%Y-%m-%d')
    force = settings.force
    jar_name = VANILLA_JAR_NAME.format(settings.mc_version)
    mem_format = settings.mem_format
    mem_max = settings.mem_max
    mem_min = settings.mem_min
    launch_server = 'java -Xms{0}{2} -Xmx{1}{2} -jar {3} nogui'.format(mem_min, mem_max, mem_format[0], jar_name)
    screen_name = settings.screen_name
    server_dir = settings.server_dir
    world_name = settings.world_name
    z = settings.z

    backup_file = '{0}_{1}.tar.{2}'.format(date_stamp, world_name, z)
    full_path_to_backup_file = os.path.join(backup_dir, backup_file)
    server_running = is_server_running(server_dir)

    if offline:
        print(print_pre + Colors.light_blue, end=' ')
        if server_running:
            server_pid = server_running[-1]
            print('Stopping "{}" ...'.format(world_name), end=' ')
            sys.stdout.flush()
            send_command('stop', screen_name)
            while os.path.exists("/proc/{0}".format(server_pid)):
                # in case we've tried to stop before the server has fully started
                time.sleep(0.5)
                send_command('stop', screen_name)
            print('backing up ...', end=' ')
        else:
            print('Backing up "{}" ...'.format(world_name), end=' ')
        sys.stdout.flush()
    else:
        print(print_pre + Colors.light_blue + 'Running live backup of "{}"  ...'.format(world_name), end=' ')
        sys.stdout.flush()
        send_command('say Server backing up now', screen_name)

    if not force:
        try:
            with open(full_path_to_backup_file, 'rb'):
                raise BackupFileAlreadyExistsError('File "{}" already exists!'.format(full_path_to_backup_file))
        except FileNotFoundError:
            pass

    tar = tarfile.open(full_path_to_backup_file, 'w:{}'.format(z))
    tar.add(server_dir)
    tar.close()

    if not offline:
        send_command('say Backup complete', screen_name)

    screen_started = is_screen_started(screen_name)
    server_running = is_server_running(server_dir)
    if offline and not server_running:
        if not screen_started:
            start_screen(screen_name, server_dir)
        print('starting "{}" ...'.format(world_name), end=' ')
        sys.stdout.flush()
        send_command(launch_server, screen_name)
    print('Done!')


def validate_port(port_num):
    """
    Ensure that the provided port is usable.

    @param port_num:
    @return:
    """
    # TODO
    pass


def validate_settings(settings):
    """
    Ensures that all required settings have a value.

    @param settings:
    @return:
    """
    missing = []
    for setting, value in settings.__dict__.items():
        if setting in REQUIRED and value is None:
            missing.append(setting)
    if missing:
        raise EmptySettingError('One or more required settings are not present: {}'.format(' '.join(missing)))
    else:
        return True


def write_server_properties(print_pre, file, settings):
    """
    Checks for a server.properties for the specified server_dir
    and world_name, and writes if need be (or forced)

    @param print_pre:
    @param file:
    @param settings:
    @return:
    """
    def do_the_write():
        print(print_pre + Colors.light_blue + 'Generating server.properties ...', end=' ')
        sys.stdout.flush()
        file_to_write = open(file, 'w')
        for l in settings.as_serverproperties().split('\n'):
            file_to_write.write(l + '\n')
        file_to_write.close()
        print('Done!' + Colors.end)

    found_msg = print_pre + Colors.light_blue + 'Found server.properties!' + Colors.end
    if os.path.isfile(file):
        f = open(file, 'r')
        f_readlines = f.readlines()
        # Write a new file if any of the three values we change have changed
        if not 'level-name={}\n'.format(settings.world_name) in f_readlines \
            or not 'server-port={}\n'.format(settings.port) in f_readlines \
            or not 'level-seed={}\n'.format(settings.level_seed or '') in f_readlines \
                or settings.force:
            do_the_write()
        else:
            print(found_msg)
        f.close()
    else:
        do_the_write()


# functions for web, if bottle.py is installed
if bottle:
    logging.basicConfig(format='127.0.0.1 - - [%(asctime)s] %(message)s', level=logging.DEBUG)
    os.chdir(BASE_DIR)

    app = bottle.app()
    log = logging.getLogger(__name__)
    static_path = os.path.join(BASE_DIR, 'data/static')
    tpl_path = os.path.join(BASE_DIR, 'data/tpl')

    bottle.debug(True)  # TODO: disable
    bottle.TEMPLATE_PATH.insert(0, tpl_path)

    if markdown:
        # only provide these pages if we have Markdown installed
        def generate_readme_tpl(readme, tpl):
            """
            Runs markdown() on a markdown-formatted README.md file to generate an html file.

            @param readme:
            @param tpl:
            @return:
            """
            # TODO: add logic that checks whether or not the page needs to be generated
            r = open(readme, 'r')
            t = open(tpl, 'w')

            [t.write(markdown(l)) for l in r.readlines()]
            r.close()
            t.close()

            # Add the footer
            t = open(tpl, 'a')
            t.write("\n%rebase base.tpl title='README.md'")
            t.close()

        @bottle.route('/readme')
        @bottle.view('readme')
        def readme_page():
            generate_readme_tpl('README.md', 'data/views/readme.tpl')
            return {}
    else:
        @bottle.route('/readme')
        @bottle.view('readme_no_md')
        def readme_page():
            return {}

    @bottle.route('/')
    @bottle.view('index')
    def index_page():
        ip = bottle.request.environ.get('REMOTE_ADDR')
        return {'ip': ip}

    # noinspection PyUnresolvedReferences
    @bottle.route('/static/<file_path:path>')
    def serve_static(file_path):
        return bottle.static_file(file_path, root=static_path)

    @bottle.error(404)
    @bottle.view('404')
    def error404(error):
        return {'error': error}

    @bottle.error(500)
    @bottle.view('500')
    def error500(error):
        return {'error': error}


def arg_parse(argz):
    parser = argparse.ArgumentParser(description=DESCRIPTION, prog=__progname__)

    actions = parser.add_mutually_exclusive_group(required=True)
    actions.add_argument('-b', '--backup', action='store_true', help='back up your Minecraft server (live)')
    actions.add_argument('-C', '--create', action='store_true', help='create a server from settings')
    actions.add_argument('-g', '--genconf', action='store_true', help='generate conf file from passed-in CLI arguments')
    actions.add_argument('-j', '--json', action='store_true', help='Output settings as json')
    actions.add_argument('-o', '--offline', action='store_true', help='make an offline backup (stops the server)')
    actions.add_argument('-r', '--restart', action='store_true', help='restart the server')
    actions.add_argument('--start', action='store_true', help='start the server in a screen session')
    actions.add_argument('--stop', action='store_true', help='stop the server')
    actions.add_argument('-W', '--web', action='store_true', help='run the web UI')

    settings = parser.add_argument_group('Settings', 'Config options for %(prog)s')
    settings.add_argument('-c', '--conf', help='config file containing your settings', metavar='CONF FILE')
    settings.add_argument('-d', '--backup-dir', help='the FULL path to your backups folder',
                          metavar='/path/to/backups/')
    settings.add_argument('--force', help='forces writing of server files, even when they already exist',
                          action='store_true')
    settings.add_argument('--forge', help='does this server use Forge?', action='store_true')
    settings.add_argument('--level-seed', '--seed', help='Optional and only applied during world creation')
    settings.add_argument('-p', '--port', help='port you wish to run your server on. Default: 25565')
    settings.add_argument('-s', '--server-dir', metavar='/path/to/server/',
                          help='set the FULL path to the directory containing your server files')
    settings.add_argument('-S', '--screen', metavar='SCREEN NAME',
                          help='set the name of your Minecraft world. Default: {}'.format(DEFAULT_SCREEN_NAME))
    settings.add_argument('-v', '--mc-version', metavar='MC VERSION',
                          help='set the version of minecraft. Default: The latest stable')
    settings.add_argument('-w', '--world', help='set the name of your Minecraft world', metavar='WORLD NAME')
    settings.add_argument('-z', '--compression', choices=['bz2', 'gz', 'xz'], dest='z',
                          help='select compression type. Default: gzip')

    mem_values = settings.add_mutually_exclusive_group()
    mem_values.add_argument('-gb', '-GB', help='set min/max memory usage (in gigabytes)',
                            metavar=('MIN', 'MAX'), nargs=2)
    mem_values.add_argument('-mb', '-MB', help='set min/max memory usage (in megabytes)',
                            metavar=('MIN', 'MAX'), nargs=2)
    parser.add_argument('-V', '--version', action='version', version='%(prog)s {0}'.format(__version__))

    settings = SweetpotatoConfig()

    try:
        read_conf_file(DEFAULT_CONF_FILE, settings)
    except ConfFileError:
        pass
    # TODO: read from json input?

    args = parser.parse_args(argz)
    if args.conf:
        try:
            read_conf_file(args.conf, settings)
        except ConfFileError as e:
            error_and_die(e)
        settings.conf_file = args.conf
    if args.backup_dir:
        settings.backup_dir = args.backup_dir
    if args.force:
        settings.force = args.force
    if args.forge:
        settings.forge = args.forge
    if args.mb:
        settings.mem_format = 'MB'
        settings.mem_max = args.mb[0]
        settings.mem_min = args.mb[1]
    elif args.gb:
        settings.mem_format = 'GB'
        settings.mem_max = args.gb[0]
        settings.mem_min = args.gb[1]
    if args.level_seed:
        settings.level_seed = args.level_seed
    if args.port:
        settings.port = args.port
    if args.server_dir:
        settings.server_dir = args.server_dir
    if args.screen:
        settings.screen_name = args.screen
    if args.mc_version:
        settings.mc_version = args.mc_version
    if args.world:
        settings.world_name = args.world
    if args.z:
        settings.z = args.z

    try:
        validate_settings(settings)
    except EmptySettingError as e:
        error_and_die(e)

    if args.backup:
        print_pre = '[' + Colors.yellow_green + 'live-backup' + Colors.end + '] '
        try:
            run_server_backup(print_pre, settings)
        except BackupFileAlreadyExistsError as e:
            send_command('say Backup Done!', settings.screen_name)
            error_and_die(e)
    elif args.create:
        create_server(settings)
    elif args.genconf:
        settings.as_conf_file()
    elif args.json:
        print(settings.as_json())
    elif args.offline:
        print_pre = '[' + Colors.yellow_green + 'offline-backup' + Colors.end + '] '
        try:
            run_server_backup(print_pre, settings, offline=True)
        except BackupFileAlreadyExistsError as e:
            start_server(None, settings)
            error_and_die(e)
    elif args.restart:
        print_pre = '[' + Colors.yellow_green + 'restart' + Colors.end + '] '
        try:
            restart_server(print_pre, settings)
        except BackupFileAlreadyExistsError as e:
            error_and_die(e)
    elif args.start:
        print_pre = '[' + Colors.yellow_green + 'start' + Colors.end + '] '
        try:
            start_server(print_pre, settings)
        except ServerAlreadyRunningError as e:
            error_and_die(e)
    elif args.stop:
        print_pre = '[' + Colors.yellow_green + 'stop' + Colors.end + '] '
        try:
            stop_server(
                print_pre,
                settings.screen_name,
                settings.server_dir,
                settings.world_name
            )
        except ServerNotRunningError as e:
            error_and_die(e)
    elif args.web:
        if bottle:
            bottle.run(app=app, host='127.0.0.1', quiet=False, reloader=True)
        else:
            error_and_die('The web component requires both bottle.py to function, '
                          'with python-markdown2 as an optional dependency.')
    else:
        parser.print_usage()


def main():
    # ensure dependencies are here
    try:
        dependency_check(
            get_exe_path('java'),
            get_exe_path('screen')
        )
    except MissingExeError as e:
        error_and_die(e)

    # process cli args and do our stuff
    argz = sys.argv[1:]
    arg_parse(argz)


if __name__ == '__main__':
    main()
