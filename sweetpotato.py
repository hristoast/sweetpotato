#!/usr/bin/env python3
"""
 A tool for managing Minecraft servers on GNU/Linux
"""
import argparse
try:
    import bottle
except ImportError:
    bottle = None
import configparser
import json
import logging
import os
# import pty
# import shlex
import subprocess
import sys
# import tarfile
import urllib.request

from datetime import datetime
try:
    from markdown import markdown
except ImportError:
    markdown = None


__author__ = 'Hristos N. Triantafillou <me@hristos.triantafillou.us>'
__forgeversion__ = '1.7.10-10.13.2.1230'
__license__ = 'GPLv3'
__mcversion__ = '1.8'
__progname__ = 'sweetpotato'
__version__ = '0.1 BETA'


DESCRIPTION = "Manage your Minecraft server on a GNU/Linux system."
HOME_DIR = os.getenv('HOME')
CONFIG_DIR = '{0}/.config/{1}'.format(HOME_DIR, __progname__)
LOCK_FILE_NAME = '{0}/sweetpot.lock'.format(CONFIG_DIR)
DEFAULT_CONF_FILE = '{0}/{1}.conf'.format(CONFIG_DIR, __progname__)
DEFAULT_SCREEN_NAME = 'sweetpotato_mc'
VANILLA_DL_URL = 'https://s3.amazonaws.com/Minecraft.Download/versions/{0}/{1}'
VANILLA_JAR_NAME = 'minecraft_server.{0}.jar'
REQUIRED = 'backup_dir mem_format mem_max mem_min port server_dir world_name'
UWSGI_EXE = 'uwsgi'


class Colors:
    blue = '\033[34m'
    light_blue = '\033[94m'
    yellow_green = '\033[92m'
    green = '\033[32m'
    light_red = '\033[91m'
    red = '\033[31m'
    yellow = '\033[33m'
    end = '\033[0m'


class EmptySettingError(Exception):
    """Raised when a required setting value is None."""
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return repr(self.msg)


class ConfFileError(IOError):
    """Raised when a given conf file doesn't exist or have the right section."""
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return repr(self.msg)


class SweetpotatoConfig:
    header = "# Generated by {0} at {1}\n[Settings]".format(__progname__, datetime.now().strftime('%c'))

    def __init__(self):
        self.backup_dir = None
        self.conf_file = None
        self.force = False
        self.forge = None
        self.level_seed = None
        self.mem_format = None
        self.mem_max = None
        self.mem_min = None
        self.mc_version = __mcversion__
        self.port = str(25565)
        self.screen_name = DEFAULT_SCREEN_NAME
        self.server_dir = None
        self.world_name = None
        self.z = 'gzip'

    def as_conf_file(self):
        print(self.header)
        return [
            print('{0}: {1}'.format(line, value))
            for line, value in self.__dict__.items()
            if value is not None and line is not 'conf_file' and line is not 'force'
        ]

    def as_json(self):
        return json.dumps(self.__dict__, sort_keys=True, indent=4)

    def as_serverproperties(self):
        vanilla_server_properties_18 = """## Minecraft server properties
#{0}
generator-settings=
op-permission-level=4
allow-nether=true
resource-pack-hash=
level-name={1}
enable-query=false
allow-flight=false
announce-player-achievements=true
server-port={2}
max-world-size=29999984
level-type=DEFAULT
enable-rcon=false
level-seed={3}
force-gamemode=false
server-ip=
network-compression-threshold=256
max-build-height=256
spawn-npcs=true
white-list=false
spawn-animals=true
hardcore=false
snooper-enabled=true
online-mode=true
resource-pack=
pvp=true
difficulty=1
enable-command-block=false
gamemode=0
player-idle-timeout=0
max-players=20
max-tick-time=60000
spawn-monsters=true
generate-structures=true
view-distance=10
motd=Welcome to {1}!
        """.format(self.header, self.world_name, self.port, self.level_seed or '')
        return vanilla_server_properties_18


def agree_to_eula(eula_txt, force, print_pre):
    """
    Checks for a eula.txt file in server, and verifies it contains 'eula=true'.

    @param eula_txt:
    @param force:
    @param print_pre:
    @return:
    """
    # TODO: not do this if the MC version is low enough
    if os.path.isfile(eula_txt) and not force:
        f = open(eula_txt, 'r')
        if 'eula=true' in f.read():
            f.close()
            print(print_pre + Colors.light_blue + 'Eula agreed to!' + Colors.end)
            return True
        else:
            f.close()
    print(print_pre + Colors.light_blue + 'Agreeing to the eula ...', end=' ')
    f = open(eula_txt, 'w')
    f.write('eula=true\n')
    f.close()
    print('Done!' + Colors.end)
    return True


def create_server(settings):
    """
    Check for or create the configured server dir, check for or download the
    server jar for the configured mc_version, then ensure that server.properties
    matches what our desired configurations are.

    @param settings:
    @return:
    """
    print_pre = '[' + Colors.yellow_green + 'create' + Colors.end + '] '
    force = settings.force
    mc_version = settings.mc_version
    server_dir = settings.server_dir
    world_name = settings.world_name

    print(print_pre + Colors.blue + 'Creating "{}" ...'.format(world_name) + Colors.end)
    if not os.path.isdir(server_dir):
        print(print_pre + Colors.light_blue + 'Creating {} ...'.format(server_dir), end=' ')
        sys.stdout.flush()
        list_or_create_dir(server_dir)
        print('Done!' + Colors.end)
    else:
        print(print_pre + Colors.light_blue + 'Found {}!'.format(server_dir) + Colors.end)

    if not settings.forge:
        jar_name = VANILLA_JAR_NAME.format(mc_version)
        full_jar_path = os.path.join(server_dir, jar_name)
        if not os.path.isfile(full_jar_path) or force:
            print(print_pre + Colors.light_blue + 'Downloading {} ...'.format(jar_name), end=' ')
            sys.stdout.flush()
            dl_url = VANILLA_DL_URL.format(mc_version, jar_name)
            local_jar = urllib.request.urlretrieve(dl_url, full_jar_path)[0]
            jar = open(local_jar)
            jar.close()
            print('Done!' + Colors.end)
        else:
            print(print_pre + Colors.light_blue + 'Found {}!'.format(jar_name) + Colors.end)
    else:
        print('DO FORGE THINGS!')

    eula_txt = os.path.join(server_dir, 'eula.txt')
    agree_to_eula(eula_txt, force, print_pre)

    server_properties = os.path.join(server_dir, 'server.properties')
    write_server_properties(print_pre, server_properties, settings)

    print(print_pre + Colors.blue + 'World "{}" has been created!'.format(world_name) + Colors.end)


def get_exe_path(exe):
    """
    Checks for exe in $PATH.

    @param exe:
    @return:
    """
    p = subprocess.Popen(['which', exe], stdout=subprocess.PIPE)
    byte_output = p.communicate()[0]
    return byte_output.decode().strip() or None


def error_and_die(msg):
    """
    For those times when you just want to quit and say why.

    @param msg:
    @return:
    """
    sys.stderr.write(
        Colors.light_red + 'FATAL: ' + Colors.red + msg.__str__().strip("'") + Colors.end + '\n'
    )
    sys.exit(1)


def list_or_create_dir(d):
    """
    Returns a list of config files in the config directory, creating the folder if it does not exist.

    :param d:
    """
    if not os.path.isdir(d):
        os.makedirs(d)
    return os.listdir(d)


def java_proc_check():
    """Checks for running Java processes and return the cwd, exe, and pid of any we find."""
    cwd, exe, pid = False, False, False
    p = subprocess.Popen(['pgrep', 'java'], stdout=subprocess.PIPE)
    output = p.communicate()[0]

    if output and len(output.split()) is 1:
        # One Java process
        pid = output.decode().strip()
        c = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/cwd'.format(pid)], stdout=subprocess.PIPE)
        c_out = c.communicate()[0]
        cwd = c_out.decode().split()[-1]
        e = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/exe'.format(pid)], stdout=subprocess.PIPE)
        e_out = e.communicate()[0]
        exe = e_out.decode().split()[-1]
    elif output and len(output.split()) > 1:
        # More than one Java process
        proc_list = []
        for P in output.decode().split():
            pid = P
            c = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/cwd'.format(pid)], stdout=subprocess.PIPE)
            c_out = c.communicate()[0]
            cwd = c_out.decode().split()[-1]
            e = subprocess.Popen(['/bin/ls', '-l', '/proc/{0}/exe'.format(pid)], stdout=subprocess.PIPE)
            e_out = e.communicate()[0]
            exe = e_out.decode().split()[-1]
            proc_list.append((cwd, exe, pid))
        return proc_list

    if cwd and exe and pid:
        return cwd, exe, pid
    else:
        return False


def read_conf_file(file, settings):
    """
    The arg 'file' is a conf file path, and 'settings' is a dict containing your settings.

    Checks if 'file' is actually a file, if not checks for 'DEFAULT_FILE'. If that doesn't exist, we return 'settings'
    as it was passed in, the value for 'settings["CONFIG"]' remaining 'None'.

    :param file:
    :param settings:
    """
    # TODO: handle multiple servers by using their world name as a section header name
    # TODO: come up with a system for this
    if not os.path.isfile(file):
        raise ConfFileError('The specified conf file does not exist: {}'.format(file))

    section = 'Settings'
    c = configparser.ConfigParser()
    c.read(file)

    try:
        options = c.options(section)
    except configparser.NoSectionError:
        raise ConfFileError("The specified conf file does not have a valid 'Settings' section")

    options_dict = {}
    for o in options:
        options_dict[o] = c.get(section, o)
    return settings.__dict__.update(**options_dict)


def validate_port(port_num):
    """
    Ensure that the provided port is usable.

    @param port_num:
    @return:
    """
    # TODO
    pass


def validate_settings(settings):
    """
    Ensures that all required settings have a value.

    @param settings:
    @return:
    """
    missing = []
    for setting, value in settings.__dict__.items():
        if setting in REQUIRED and value is None:
            missing.append(setting)
    if missing:
        raise EmptySettingError('One or more required settings are not present: {}'.format(' '.join(missing)))
    else:
        return True


def write_server_properties(print_pre, file, settings):
    """
    Checks for a server.properties for the specified server_dir
    and world_name, and writes if need be (or forced)

    @param print_pre:
    @param file:
    @param settings:
    @return:
    """
    def do_the_write():
        print(print_pre + Colors.light_blue + 'Generating server.properties ...', end=' ')
        sys.stdout.flush()
        file_to_write = open(file, 'w')
        for l in settings.as_serverproperties().split('\n'):
            file_to_write.write(l + '\n')
        file_to_write.close()
        print('Done!' + Colors.end)

    found_msg = print_pre + Colors.light_blue + 'Found server.properties!' + Colors.end
    if os.path.isfile(file):
        f = open(file, 'r')
        f_readlines = f.readlines()
        # Write a new file if any of the three values we change have changed
        if not 'level-name={}\n'.format(settings.world_name) in f_readlines \
            or not 'server-port={}\n'.format(settings.port) in f_readlines \
            or not 'level-seed={}\n'.format(settings.level_seed or '') in f_readlines \
                or settings.force:
            do_the_write()
        else:
            print(found_msg)
        f.close()
    else:
        do_the_write()


# functions for web, if bottle.py and uWSGI are installed
if bottle and get_exe_path(UWSGI_EXE):
    logging.basicConfig(format='localhost - - [%(asctime)s] %(message)s', level=logging.DEBUG)
    log = logging.getLogger(__name__)
    bottle.debug(True)
    bottle.TEMPLATE_PATH.insert(0, 'data/views/')  # TODO: create or change this
    os.chdir(os.path.dirname(__file__))
    app = bottle.app()

    if markdown:
        # only provide these pages if we have Markdown installed
        def generate_readme_tpl(readme, tpl):
            """
            Runs markdown() on a markdown-formatted README.md file to generate an html file.

            @param readme:
            @param tpl:
            @return:
            """
            # TODO: add logic that checks whether or not the page needs to be generated
            r = open(readme, 'r')
            t = open(tpl, 'w')

            [t.write(markdown(l)) for l in r.readlines()]
            r.close()
            t.close()

            # Add the footer
            t = open(tpl, 'a')
            t.write("\n%rebase base.tpl title='README.md'")
            t.close()

        @bottle.route('/readme')
        @bottle.view('readme')
        def readme_page():
            generate_readme_tpl('README.md', 'data/views/readme.tpl')
            return {}
    else:
        # TODO: /readme page that explains the Markdown requirement
        pass

    @bottle.route('/')
    @bottle.view('index')
    def index_page():
        return {}

    @bottle.error(404)
    @bottle.view('404')
    def error404(error):
        return {'error': error, }

    @bottle.error(500)
    @bottle.view('500')
    def error500(error):
        return {'error': error, }


def arg_parse(argz):
    parser = argparse.ArgumentParser(description=DESCRIPTION, prog=__progname__)

    actions = parser.add_mutually_exclusive_group(required=True)
    actions.add_argument('-b', '--backup', action='store_true', help='back up your Minecraft server (live)')
    actions.add_argument('-C', '--create', action='store_true', help='create a server from settings')
    actions.add_argument('-g', '--genconf', action='store_true', help='generate conf file from passed-in CLI arguments')
    actions.add_argument('-j', '--json', action='store_true', help='Output settings as json')
    actions.add_argument('-o', '--offline', action='store_true', help='make an offline backup (stops the server)')
    actions.add_argument('-r', '--restart', action='store_true', help='restart the server')
    actions.add_argument('--start', action='store_true', help='start the server in a screen session')
    actions.add_argument('--stop', action='store_true', help='stop the server')
    actions.add_argument('-W', '--web', action='store_true', help='run the web UI')

    settings = parser.add_argument_group('Settings', 'Config options for %(prog)s')
    settings.add_argument('-c', '--conf', help='config file containing your settings', metavar='CONF FILE')
    settings.add_argument('-d', '--backup-dir', help='the FULL path to your backups folder',
                          metavar='/path/to/backups/')
    settings.add_argument('--force', help='forces writing of server files, even when they already exist',
                          action='store_true')
    settings.add_argument('--forge', help='does this server use Forge?', action='store_true')
    settings.add_argument('--level-seed', '--seed', help='Optional and only applied during world creation')
    settings.add_argument('-p', '--port', help='port you wish to run your server on. Default: 25565')
    settings.add_argument('-s', '--server-dir', metavar='/path/to/server/',
                          help='set the FULL path to the directory containing your server files')
    settings.add_argument('-S', '--screen', metavar='SCREEN NAME',
                          help='set the name of your Minecraft world. Default: {}'.format(DEFAULT_SCREEN_NAME))
    settings.add_argument('-v', '--mc-version', metavar='MC VERSION',
                          help='set the version of minecraft. Default: The latest stable')
    settings.add_argument('-w', '--world', help='set the name of your Minecraft world', metavar='WORLD NAME')
    settings.add_argument('-z', '--compression', choices=['bzip2', 'gzip', 'xz'], dest='z',
                          help='select compression type. Default: gzip')

    mem_values = settings.add_mutually_exclusive_group()
    mem_values.add_argument('-gb', '-GB', help='set min/max memory usage (in gigabytes)',
                            metavar=('MIN', 'MAX'), nargs=2)
    mem_values.add_argument('-mb', '-MB', help='set min/max memory usage (in megabytes)',
                            metavar=('MIN', 'MAX'), nargs=2)
    parser.add_argument('-V', '--version', action='version', version='%(prog)s {0}'.format(__version__))

    settings = SweetpotatoConfig()

    try:
        read_conf_file(DEFAULT_CONF_FILE, settings)
    except ConfFileError:
        pass
    # TODO: read from json input?

    args = parser.parse_args(argz)
    if args.conf:
        try:
            read_conf_file(args.conf, settings)
        except ConfFileError as e:
            error_and_die(e)
        settings.conf_file = args.conf
    if args.backup_dir:
        settings.backup_dir = args.backup_dir
    if args.force:
        settings.force = args.force
    if args.forge:
        settings.forge = args.forge
    if args.mb:
        settings.mem_format = 'MB'
        settings.mem_max = args.mb[0]
        settings.mem_min = args.mb[1]
    elif args.gb:
        settings.mem_format = 'GB'
        settings.mem_max = args.gb[0]
        settings.mem_min = args.gb[1]
    if args.level_seed:
        settings.level_seed = args.level_seed
    if args.port:
        settings.port = args.port
    if args.server_dir:
        settings.server_dir = args.server_dir
    if args.screen:
        settings.screen_name = args.screen
    if args.mc_version:
        settings.mc_version = args.mc_version
    if args.world:
        settings.world_name = args.world
    if args.z:
        settings.z = args.z

    try:
        validate_settings(settings)
    except EmptySettingError as e:
        error_and_die(e)

    if args.backup:
        print('-b: Live Backup YEY!')
    elif args.create:
        create_server(settings)
    elif args.genconf:
        settings.as_conf_file()
    elif args.json:
        print(settings.as_json())
    elif args.offline:
        print('-o: Offline Backup YEY!')
    elif args.restart:
        print('-r: Restart YEY!')
    elif args.start:
        print('--start: Start YEY!')
    elif args.stop:
        print('--stop: Stop YEY!')
    elif args.web:
        if bottle and get_exe_path(UWSGI_EXE):
            print('--web: Web UI YEY!')
        else:
            error_and_die('The web component requires both bottle.py and uWSGI to function, '
                          'with python-markdown2 as an optional dependency.')
    else:
        parser.print_usage()


def main():
    argz = sys.argv[1:]
    arg_parse(argz)


if __name__ == '__main__':
    main()
